module.exports = {
  // Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
  typeDefs:
    // Please don't change this file manually but run `prisma generate` to update it.
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

    /* GraphQL */ `
      type AggregateComment {
        count: Int!
      }

      type AggregateMessage {
        count: Int!
      }

      type BatchPayload {
        count: Long!
      }

      type Comment {
        id: ID!
        comment: String!
        author: String!
        dislikes: Int!
        date: String!
        message: Message!
      }

      type CommentConnection {
        pageInfo: PageInfo!
        edges: [CommentEdge]!
        aggregate: AggregateComment!
      }

      input CommentCreateInput {
        id: ID
        comment: String!
        author: String!
        dislikes: Int!
        date: String!
        message: MessageCreateOneWithoutCommentsInput!
      }

      input CommentCreateManyWithoutMessageInput {
        create: [CommentCreateWithoutMessageInput!]
        connect: [CommentWhereUniqueInput!]
      }

      input CommentCreateWithoutMessageInput {
        id: ID
        comment: String!
        author: String!
        dislikes: Int!
        date: String!
      }

      type CommentEdge {
        node: Comment!
        cursor: String!
      }

      enum CommentOrderByInput {
        id_ASC
        id_DESC
        comment_ASC
        comment_DESC
        author_ASC
        author_DESC
        dislikes_ASC
        dislikes_DESC
        date_ASC
        date_DESC
      }

      type CommentPreviousValues {
        id: ID!
        comment: String!
        author: String!
        dislikes: Int!
        date: String!
      }

      input CommentScalarWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        comment: String
        comment_not: String
        comment_in: [String!]
        comment_not_in: [String!]
        comment_lt: String
        comment_lte: String
        comment_gt: String
        comment_gte: String
        comment_contains: String
        comment_not_contains: String
        comment_starts_with: String
        comment_not_starts_with: String
        comment_ends_with: String
        comment_not_ends_with: String
        author: String
        author_not: String
        author_in: [String!]
        author_not_in: [String!]
        author_lt: String
        author_lte: String
        author_gt: String
        author_gte: String
        author_contains: String
        author_not_contains: String
        author_starts_with: String
        author_not_starts_with: String
        author_ends_with: String
        author_not_ends_with: String
        dislikes: Int
        dislikes_not: Int
        dislikes_in: [Int!]
        dislikes_not_in: [Int!]
        dislikes_lt: Int
        dislikes_lte: Int
        dislikes_gt: Int
        dislikes_gte: Int
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        AND: [CommentScalarWhereInput!]
        OR: [CommentScalarWhereInput!]
        NOT: [CommentScalarWhereInput!]
      }

      type CommentSubscriptionPayload {
        mutation: MutationType!
        node: Comment
        updatedFields: [String!]
        previousValues: CommentPreviousValues
      }

      input CommentSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: CommentWhereInput
        AND: [CommentSubscriptionWhereInput!]
        OR: [CommentSubscriptionWhereInput!]
        NOT: [CommentSubscriptionWhereInput!]
      }

      input CommentUpdateInput {
        comment: String
        author: String
        dislikes: Int
        date: String
        message: MessageUpdateOneRequiredWithoutCommentsInput
      }

      input CommentUpdateManyDataInput {
        comment: String
        author: String
        dislikes: Int
        date: String
      }

      input CommentUpdateManyMutationInput {
        comment: String
        author: String
        dislikes: Int
        date: String
      }

      input CommentUpdateManyWithoutMessageInput {
        create: [CommentCreateWithoutMessageInput!]
        delete: [CommentWhereUniqueInput!]
        connect: [CommentWhereUniqueInput!]
        set: [CommentWhereUniqueInput!]
        disconnect: [CommentWhereUniqueInput!]
        update: [CommentUpdateWithWhereUniqueWithoutMessageInput!]
        upsert: [CommentUpsertWithWhereUniqueWithoutMessageInput!]
        deleteMany: [CommentScalarWhereInput!]
        updateMany: [CommentUpdateManyWithWhereNestedInput!]
      }

      input CommentUpdateManyWithWhereNestedInput {
        where: CommentScalarWhereInput!
        data: CommentUpdateManyDataInput!
      }

      input CommentUpdateWithoutMessageDataInput {
        comment: String
        author: String
        dislikes: Int
        date: String
      }

      input CommentUpdateWithWhereUniqueWithoutMessageInput {
        where: CommentWhereUniqueInput!
        data: CommentUpdateWithoutMessageDataInput!
      }

      input CommentUpsertWithWhereUniqueWithoutMessageInput {
        where: CommentWhereUniqueInput!
        update: CommentUpdateWithoutMessageDataInput!
        create: CommentCreateWithoutMessageInput!
      }

      input CommentWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        comment: String
        comment_not: String
        comment_in: [String!]
        comment_not_in: [String!]
        comment_lt: String
        comment_lte: String
        comment_gt: String
        comment_gte: String
        comment_contains: String
        comment_not_contains: String
        comment_starts_with: String
        comment_not_starts_with: String
        comment_ends_with: String
        comment_not_ends_with: String
        author: String
        author_not: String
        author_in: [String!]
        author_not_in: [String!]
        author_lt: String
        author_lte: String
        author_gt: String
        author_gte: String
        author_contains: String
        author_not_contains: String
        author_starts_with: String
        author_not_starts_with: String
        author_ends_with: String
        author_not_ends_with: String
        dislikes: Int
        dislikes_not: Int
        dislikes_in: [Int!]
        dislikes_not_in: [Int!]
        dislikes_lt: Int
        dislikes_lte: Int
        dislikes_gt: Int
        dislikes_gte: Int
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        message: MessageWhereInput
        AND: [CommentWhereInput!]
        OR: [CommentWhereInput!]
        NOT: [CommentWhereInput!]
      }

      input CommentWhereUniqueInput {
        id: ID
      }

      scalar Long

      type Message {
        id: ID!
        title: String!
        message: String!
        author: String!
        dislikes: Int!
        comments(
          where: CommentWhereInput
          orderBy: CommentOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Comment!]
        date: String
      }

      type MessageConnection {
        pageInfo: PageInfo!
        edges: [MessageEdge]!
        aggregate: AggregateMessage!
      }

      input MessageCreateInput {
        id: ID
        title: String!
        message: String!
        author: String!
        dislikes: Int!
        comments: CommentCreateManyWithoutMessageInput
        date: String
      }

      input MessageCreateOneWithoutCommentsInput {
        create: MessageCreateWithoutCommentsInput
        connect: MessageWhereUniqueInput
      }

      input MessageCreateWithoutCommentsInput {
        id: ID
        title: String!
        message: String!
        author: String!
        dislikes: Int!
        date: String
      }

      type MessageEdge {
        node: Message!
        cursor: String!
      }

      enum MessageOrderByInput {
        id_ASC
        id_DESC
        title_ASC
        title_DESC
        message_ASC
        message_DESC
        author_ASC
        author_DESC
        dislikes_ASC
        dislikes_DESC
        date_ASC
        date_DESC
      }

      type MessagePreviousValues {
        id: ID!
        title: String!
        message: String!
        author: String!
        dislikes: Int!
        date: String
      }

      type MessageSubscriptionPayload {
        mutation: MutationType!
        node: Message
        updatedFields: [String!]
        previousValues: MessagePreviousValues
      }

      input MessageSubscriptionWhereInput {
        mutation_in: [MutationType!]
        updatedFields_contains: String
        updatedFields_contains_every: [String!]
        updatedFields_contains_some: [String!]
        node: MessageWhereInput
        AND: [MessageSubscriptionWhereInput!]
        OR: [MessageSubscriptionWhereInput!]
        NOT: [MessageSubscriptionWhereInput!]
      }

      input MessageUpdateInput {
        title: String
        message: String
        author: String
        dislikes: Int
        comments: CommentUpdateManyWithoutMessageInput
        date: String
      }

      input MessageUpdateManyMutationInput {
        title: String
        message: String
        author: String
        dislikes: Int
        date: String
      }

      input MessageUpdateOneRequiredWithoutCommentsInput {
        create: MessageCreateWithoutCommentsInput
        update: MessageUpdateWithoutCommentsDataInput
        upsert: MessageUpsertWithoutCommentsInput
        connect: MessageWhereUniqueInput
      }

      input MessageUpdateWithoutCommentsDataInput {
        title: String
        message: String
        author: String
        dislikes: Int
        date: String
      }

      input MessageUpsertWithoutCommentsInput {
        update: MessageUpdateWithoutCommentsDataInput!
        create: MessageCreateWithoutCommentsInput!
      }

      input MessageWhereInput {
        id: ID
        id_not: ID
        id_in: [ID!]
        id_not_in: [ID!]
        id_lt: ID
        id_lte: ID
        id_gt: ID
        id_gte: ID
        id_contains: ID
        id_not_contains: ID
        id_starts_with: ID
        id_not_starts_with: ID
        id_ends_with: ID
        id_not_ends_with: ID
        title: String
        title_not: String
        title_in: [String!]
        title_not_in: [String!]
        title_lt: String
        title_lte: String
        title_gt: String
        title_gte: String
        title_contains: String
        title_not_contains: String
        title_starts_with: String
        title_not_starts_with: String
        title_ends_with: String
        title_not_ends_with: String
        message: String
        message_not: String
        message_in: [String!]
        message_not_in: [String!]
        message_lt: String
        message_lte: String
        message_gt: String
        message_gte: String
        message_contains: String
        message_not_contains: String
        message_starts_with: String
        message_not_starts_with: String
        message_ends_with: String
        message_not_ends_with: String
        author: String
        author_not: String
        author_in: [String!]
        author_not_in: [String!]
        author_lt: String
        author_lte: String
        author_gt: String
        author_gte: String
        author_contains: String
        author_not_contains: String
        author_starts_with: String
        author_not_starts_with: String
        author_ends_with: String
        author_not_ends_with: String
        dislikes: Int
        dislikes_not: Int
        dislikes_in: [Int!]
        dislikes_not_in: [Int!]
        dislikes_lt: Int
        dislikes_lte: Int
        dislikes_gt: Int
        dislikes_gte: Int
        comments_every: CommentWhereInput
        comments_some: CommentWhereInput
        comments_none: CommentWhereInput
        date: String
        date_not: String
        date_in: [String!]
        date_not_in: [String!]
        date_lt: String
        date_lte: String
        date_gt: String
        date_gte: String
        date_contains: String
        date_not_contains: String
        date_starts_with: String
        date_not_starts_with: String
        date_ends_with: String
        date_not_ends_with: String
        AND: [MessageWhereInput!]
        OR: [MessageWhereInput!]
        NOT: [MessageWhereInput!]
      }

      input MessageWhereUniqueInput {
        id: ID
      }

      type Mutation {
        createComment(data: CommentCreateInput!): Comment!
        updateComment(
          data: CommentUpdateInput!
          where: CommentWhereUniqueInput!
        ): Comment
        updateManyComments(
          data: CommentUpdateManyMutationInput!
          where: CommentWhereInput
        ): BatchPayload!
        upsertComment(
          where: CommentWhereUniqueInput!
          create: CommentCreateInput!
          update: CommentUpdateInput!
        ): Comment!
        deleteComment(where: CommentWhereUniqueInput!): Comment
        deleteManyComments(where: CommentWhereInput): BatchPayload!
        createMessage(data: MessageCreateInput!): Message!
        updateMessage(
          data: MessageUpdateInput!
          where: MessageWhereUniqueInput!
        ): Message
        updateManyMessages(
          data: MessageUpdateManyMutationInput!
          where: MessageWhereInput
        ): BatchPayload!
        upsertMessage(
          where: MessageWhereUniqueInput!
          create: MessageCreateInput!
          update: MessageUpdateInput!
        ): Message!
        deleteMessage(where: MessageWhereUniqueInput!): Message
        deleteManyMessages(where: MessageWhereInput): BatchPayload!
      }

      enum MutationType {
        CREATED
        UPDATED
        DELETED
      }

      interface Node {
        id: ID!
      }

      type PageInfo {
        hasNextPage: Boolean!
        hasPreviousPage: Boolean!
        startCursor: String
        endCursor: String
      }

      type Query {
        comment(where: CommentWhereUniqueInput!): Comment
        comments(
          where: CommentWhereInput
          orderBy: CommentOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Comment]!
        commentsConnection(
          where: CommentWhereInput
          orderBy: CommentOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): CommentConnection!
        message(where: MessageWhereUniqueInput!): Message
        messages(
          where: MessageWhereInput
          orderBy: MessageOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): [Message]!
        messagesConnection(
          where: MessageWhereInput
          orderBy: MessageOrderByInput
          skip: Int
          after: String
          before: String
          first: Int
          last: Int
        ): MessageConnection!
        node(id: ID!): Node
      }

      type Subscription {
        comment(
          where: CommentSubscriptionWhereInput
        ): CommentSubscriptionPayload
        message(
          where: MessageSubscriptionWhereInput
        ): MessageSubscriptionPayload
      }
    `
};
